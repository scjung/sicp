\chapter{\Large{Building Abstractions with Procedures}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.1}
\begin{scheme}
> 10
10
\end{scheme}
\begin{scheme}
> (+ 5 3 4)
12
\end{scheme}
\begin{scheme}
> (- 9 1)
8
\end{scheme}
\begin{scheme}
> (/ 6 2)
3
\end{scheme}
\begin{scheme}
> (+ (* 2 4) (- 4 6))
> (+ 8 -2)
6
\end{scheme}
\begin{scheme}
> (define a 3)
> (define b (+ a 1))
\end{scheme}
\begin{scheme}
> (+ a b (* a b))
> (+ 3 4 (* 3 4))
> (+ 3 4 12)
19
\end{scheme}
\begin{scheme}
> (= a b)
> (= 3 4)
#f
\end{scheme}
\begin{scheme}
> (if (and (> b a) (< b (* a b))) b a)
> (if (and (> 4 3) (< 4 (* 3 4))) 4 3)
> (if (and #t (< 4 12)) 4 3)
> (if (and #t #t) 4 3)
4
\end{scheme}
\begin{scheme}
> (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
> (cond ((= 3 4) 6)
        ((= 4 4) (+ 6 7 3))
        (else 25))
> (+ 6 7 3)
16
\end{scheme}
\begin{scheme}
> (+ 2 (if (> b a) b a))
> (+ 2 (if (> 4 3) 4 3))
> (+ 2 4)
6
\end{scheme}
\begin{scheme}
> (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
> (* (cond ((> 3 4) 3)
           ((< 3 4) 4)
           (else -1))
     (+ 3 1))
> (* 4 4)
16
\end{scheme}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.2}
\begin{scheme}
(/ (+ 5 4
      (- 2
         (- 3
            (+ 6 (/ 4 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
\end{scheme}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.3}
\schemein{./src/ch01-ex03.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.4}
두번째 인자가 양수일때는 연산자가 \texttt{+}가 되므로 두 인자를 더하며,
음수일때는 연산자가 \texttt{-}가 되므로 두 인자를 뺀다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.5}
우선 applicative-order evaluation의 경우에는 다음과 같이 계산된다.
\begin{scheme}
> (test 0 (p))
> (test 0 (p))
> (test 0 (p))
  ...
\end{scheme}
이 경우에는 프로시저 \texttt{test}를 펼치기에 앞서 주어진 인자를 먼저 계산하여야
한다. 그런데 두번째 인자 \texttt{p}의 정의에 따르면 계산을 위해 아무리
치환하여도 다시 자기 자신으로 바뀌어 버리므로 치환은 영원히 끝나지 않는다. 즉
\texttt{(test 0 (p))}을 applicative-order evaluation 방식으로 계산하는 것은
불가능하다.\\

반면에 normal-order evaluation의 경우에는 다음과 같이 계산된다.
\begin{scheme}
> (test 0 (p))
> (if (= 0 0)
      0
      (p))
0
\end{scheme}
\texttt{p}에 대한 계산은 필요치 않으므로 무시되며, 따라서 \texttt{(test 0
  (p))}는 정상적으로 계산된다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.6}

\SCHEME의 프로시저 계산은 applicative-order evaluation 방식으로 수행되므로,
\texttt{new-if}를 풀어내기 전 먼저 인자로 들어오는 \texttt{predicate},
\texttt{then-clause}, \texttt{else-clause}를 계산하여야 한다. 그런데 새로
작성된 \texttt{sqrt-iter}에서 \texttt{new-if}에 주어지는
\texttt{else-clause}를 계산하려면 \texttt{sqrt-iter}를 계산해야 한다. 즉,
\texttt{sqrt-iter}를 계산하기 위해서 \texttt{sqrt-iter}를 계산해야 하므로
안자가 끝없이 풀리면서 프로시저 계산이 끝나지 않게 된다.\\

반면에 기존의 \texttt{if}는 \texttt{predicate}을 먼저 계산하고 난 후에
\texttt{then-clause}, \texttt{else-clause} 중 해당하는 표현식을 계산하므로
이러한 문제가 발생하지 않는다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.7}

교재의 프로그램으로는 다음과 같이 아주 작은 수의 제곱근을 정확히 찾지
못한다. 이는 \texttt{good-enough?}에서 쓰인 허용치로 얻을 수 있는 정확도가
구하려는 제곱근에 못 미치기 때문이다.

\begin{scheme}
> (sqrt (square 0.001))
0.03126065525445276
\end{scheme}

반대로 아주 큰 수에 대해서는 실수값 정확도의 한계로 인해 몫과 평균값이 정확히
구해지지 않아, 그 차이가 \texttt{good-enough?}에 쓰인 허용치 밖을 맴도는
현상이 발생할 수 있다. 이런 경우에는 계산이 끝나지 않게 된다. 예를 들어 다음과
같은 표현식은 대부분의 컴퓨터에서 계산해 낼 수 없다.

\begin{scheme}
> (sqrt 1e13)
\end{scheme}

다음은 이러한 문제를 해결하기 위해 교재에서 제안한 방식대로 구현한 코드이다
(이전과 동일한 프로시저는 생략함).

\schemein{./src/ch01-ex07.ss}

9,10번째 줄에 새로 정의된 \texttt{good-enough?} 프로시저가 나와 있다. 인자
\texttt{old-guess}는 이전에 찾아낸 제곱근을, \texttt{guess}는
\texttt{old-guess}를 바탕으로 좀 더 정확히 구한 제곱근을 의미한다. 이 둘
사이의 차가 특정 수 이하가 되면 (즉, \texttt{improve} 프로시저가 만들어낸
차이가 미미할 경우) \texttt{sqrt-iter}는 계산을 마치게 된다. 19,20번째 줄의
\texttt{sqrt} 역시 변경되었는데, 이는 맨 처음 단계에서 항상 \texttt{improve}를
수행하도록 하기 위함이다.\\

다음은 새로 작성한 프로그램으로 아주 작은 수와 큰 수의 제곱근을 구한
것이다. 이전과 달리 문제없이 제곱근을 구할 수 있다.
\begin{scheme}
> (sqrt (square 0.001))
0.0010000001533016628
> (sqrt 1e13)
3162277.6601683795
\end{scheme}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.8}

앞에서 작성한 제곱근 프로그램에서 \texttt{improve} 프로시저만 제시된 식처럼
수정하면 된다.

\schemein{./src/ch01-ex08.ss}

다음은 작성한 프로그램으로 여러 세제곱근을 구한 것이다.
\begin{scheme}
> (sqrt 8)
2.000000000012062
> (sqrt (* 0.001 0.001 0.001))
0.0010000009808132022
> (sqrt (* 1e13 1e13 1e13))
10000000000000.0
\end{scheme}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.9}

첫번째 방식으로 구현되었을때 \texttt{(+ 4 5)}가 계산되는 과정은 다음과 같다.

\begin{scheme}
> (+ 4 5)
> (if (= 4 0) 5 (inc (+ (dec 4) 5)))
> (inc (+ 3 5))
> (inc (if (= 3 0) 5 (inc (+ (dec 3) 5))))
> (inc (inc (+ 2 5)))
> (inc (inc (if (= 2 0) 5 (inc (+ (dec 2) 5)))))
> (inc (inc (inc (+ 1 5))))
> (inc (inc (inc (if (= 1 0) 5 (inc (+ (dec 1) 5))))))
> (inc (inc (inc (inc (+ 0 5)))))
> (inc (inc (inc (inc (if (= 0 0) 5 (inc (+ (dec 0) 5)))))))
> (inc (inc (inc (inc 5))))
> (inc (inc (inc 6)))
> (inc (inc 7))
> (inc 8)
9
\end{scheme}

즉 첫번째 인자에 선형인 재귀 프로세스이다.\\

다음은 두번째 방식으로 구현되었을때 \texttt{(+ 4 5)}가 계산되는 과정이다.

\begin{scheme}
> (+ 4 5)
> (if (= 4 0) 5 (+ (dec 4) (inc 5)))
> (+ 3 6)
> (if (= 3 0) 6 (+ (dec 3) (inc 6)))
> (+ 2 7)
> (if (= 2 0) 7 (+ (dec 2) (inc 7)))
> (+ 1 8)
> (if (= 1 0) 8 (+ (dec 1) (inc 8)))
> (+ 0 9)
> (if (= 0 0) 9 (+ (dec 0) (inc 9)))
9
\end{scheme}

앞의 구현과 달리 여기서는 첫번째 인자에 선형으로 반복 프로세스를
수행한다. 이는 교재의 \texttt{fact-iter}와 유사한 구현이다. 주어지는 첫번째
인자는 \texttt{fact-iter}의 \texttt{counter}와 같이 반복이 얼마나 더
수행되어야 하는지를 나타낸다. 그리고 두번째 인자는 \texttt{fact-iter}의
\texttt{product}와 같이 이제까지 구해낸 부분합을 나타낸다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.10}

이하는 주어진 표현식이 계산되는 과정을 나타낸 것이다. 간략하게 표현하기 위해
프로시저 몸체로 치환되는 과정은 생략하였다.

\begin{scheme}
> (A 1 10)
> (A 0 (A 1 9))
> (A 0 (A 0 (A 1 8)))
> (A 0 (A 0 (A 0 (A 1 7))))
> (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
> (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
> (A 0 (A 0 (A 0 (A 0 64))))
> (A 0 (A 0 (A 0 128)))
> (A 0 (A 0 256))
> (A 0 512)
1024
\end{scheme}

\begin{scheme}
> (A 2 4)
> (A 1 (A 2 3))
> (A 1 (A 1 (A 2 2)))
> (A 1 (A 1 (A 1 (A 2 1))))
> (A 1 (A 1 (A 1 2)))
> (A 1 (A 1 (A 0 (A 1 1))))
> (A 1 (A 1 (A 0 2)))
> (A 1 (A 1 4))
> (A 1 (A 0 (A 1 3)))
> (A 1 (A 0 (A 0 (A 1 2))))
> (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
> (A 1 (A 0 (A 0 (A 0 2))))
> (A 1 (A 0 (A 0 4)))
> (A 1 (A 0 8))
> (A 1 16)
  ...
65536
\end{scheme}

\begin{scheme}
> (A 3 3)
  ...
65536
\end{scheme}

프로시저 \texttt{f}는 \texttt{A}에 첫번째
인자로 \texttt{0}을 주므로 항상 \texttt{A} 내 \texttt{cond}의 두번째 경우로
계산된다. 따라서 \texttt{(f n)}은 $2n$을 계산하는 것과 동일하다.\\

프로시저 \texttt{g}에 임의의 수를 넣어보면 다음과 같은 결과가 나온다.

\begin{scheme}
> (g 0)
0
> (g 1)
2
> (g 2)
> (A 0 (A 1 1))
> (A 0 2)
4
> (g 3)
> (A 0 (A 1 2))
> (A 0 (A 0 (A 1 1)))
> (A 0 (A 0 2))
> (A 0 2)
8
> (g 4)
16
  ...
\end{scheme}

실제로 프로시저 \texttt{g}가 계산되는 과정을 자세히 살펴보면, 우선 주어진 인자만큼
식 바깥쪽에 \texttt{(A 0 ...)}이 붙고, 맨 안쪽 식의 두번째 인자는 계속
줄어든다. 그러다가 맨 안쪽 식이 \texttt{(A 1 1)}의 형태를 이루면, 이것은
\texttt{A}의 정의에 따라 \texttt{2}로 치환된다. 이 다음부터는 \texttt{(A 0
  ...)}의 계산방식에 따라 맨 안쪽 값에 \texttt{2}가 계속 곱해지면서 식이
줄어들게 된다. 결론적으로, \texttt{(g~n)}은 $2^n$을 계산하는 것과 동일하다.\\

프로시저 \texttt{h}에 임의의 수를 넣어보면 다음과 같은 결과가 나온다.

\begin{scheme}
> (h 0)
1
> (h 1)
2
> (h 2)
> (A 1 (A 2 1))
> (g (h 1))        ; (A 1 n) = (g n), (A 2 n) = (h n)
4
> (h 3)
> (g (h 2))
> (g (g (h 1)))
> (g (g 2))
16
> (h 4)
> (g (g (g (h 1))))
> (g (g (g 2)))
65536
\end{scheme}

즉, \texttt{(h~n)}은 $g^{(n-1)}(2)$를 계산하는 것과 동일하다.\\

참고로 프로시저 \texttt{f}, \texttt{g}, \texttt{h} 모두 인자로 음수가 주어지면
값을 제대로 계산하지 못한다 (계산이 끝나지 않음). 따라서 엄밀히 말하면 여기서
애기한 수학적 함수를 제대로 구현한 것이라고 볼 수 없다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.11}

다음은 주어진 함수를 재귀 프로세스 및 반복 프로세스 방식으로 구현한 것이다.

\schemein{./src/ch01-ex11.ss}

반복 프로세스 방식의 구현에서 정의된 프로시저 \texttt{f-iter}에는 계산에
필요한 이전 계산값 $f(n-1)$, $f(n-2)$,$f(n-3)$이 인자로 넘어간다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.12}

파스칼의 삼각형에서 $i$번째 행의 왼쪽에서 $j$번째 수를 구하는 함수를 $f(i,j)$라
하자. 이러한 함수는 수학적으로 다음과 같이 정의할 수 있다.

\begin{equation}\notag
  f(i,j) =
  \begin{cases}
    1                    & \text{if } j=1 \vee i=j\\
    f(i-1,j-1) + f(i-1,j) & \text{otherwise}
  \end{cases}
\end{equation}
\begin{center}
  \qquad\qquad\qquad 단, $i>1$이고 $1\le j \le i$일 경우에만 정의됨
\end{center}

이를 \SCHEME으로 구현한 코드는 다음과 같다 ($f$가 정의되는 범위내 인자만
사용된다고 가정함).

\schemein{./src/ch01-ex12.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.13}

교재에서 제시된 방식대로 $\phi=(1+\sqrt{5})/2$, $\psi=(1-\sqrt{5})/2$ 일 때,
$\text{Fib}(n)=(\phi^n - \psi^n) / \sqrt{5}$임을 다음과 같이 귀납적으로 증명한다.
\newcommand{\FIB}[0]{\text{Fib}}
\begin{itemize}
\item $n=0$ 일 경우:
  \begin{align}\notag
    \FIB(0) &= 0 \\\notag
    \frac{\phi^0 - \psi^0}{\sqrt{5}} &= 0
  \end{align}
\item $n=1$ 일 경우:
  \begin{align}\notag
    \FIB(1) &= 1 \\\notag
    \frac{\phi - \psi}{\sqrt{5}} &= \frac{1+\sqrt{5}-1+\sqrt{5}}{2\sqrt{5}}
    \notag\\
    &= 1 \notag
  \end{align}
\item 귀납 가정: $n=k$ 일 경우 다음이 성립한다고 가정한다.
  \begin{align}\notag
    \FIB(k) & = \frac{\phi^k - \psi^k}{\sqrt{5}}
  \end{align}
\item $n=k+1$ 일 경우:
  \begin{align}\notag
    \FIB(k+1) &= \FIB(k) + \FIB(k-1)
  \end{align}

  귀납 가정을 $n=k-1$ 일 경우 적용하면 다음과 같다.
  \begin{align}
    \FIB(k-1) &= \frac{\phi^{k-1} - \psi^{k-1}}{\sqrt{5}}
    \notag\\
    &= \frac{\phi^k/\phi - \psi^k/\psi}{\sqrt{5}}
    \notag\\
    &= \frac{\frac{2\phi^k}{1+\sqrt{5}} - \frac{2\psi^k}{1-\sqrt{5}}}{\sqrt{5}}
    \notag\\
    &= \frac{(1+\sqrt{5})\psi^k-(1-\sqrt{5})\phi^k}{2\sqrt{5}}
    \notag\\
    &= \frac{\psi^k-\phi^k}{2\sqrt{5}}+\frac{\sqrt{5}\psi^k+\sqrt{5}\phi^k}{2\sqrt{5}}
    \notag\\
    &= \frac{-\FIB(k)}{2}+\frac{\psi^k+\phi^k}{2}
    \tag{귀납 가정에 의해, $\star$}
  \end{align}

  $n=k+1$일 경우의 증명하고자 하는 식을 정리하면 다음과 같다.
  \begin{align}
    \frac{\phi^{k+1} - \psi^{k+1}}{\sqrt{5}}
    &= \frac{(1+\sqrt{5})\phi^k-(1-\sqrt{5})\psi^k}{2\sqrt{5}}
    \notag\\
    &= \frac{\phi^k -\psi^k + \sqrt{5}\phi^k + \sqrt{5}\psi^k}{2\sqrt{5}}
    \notag\\
    &= \frac{\phi^k -\psi^k}{2\sqrt{5}} + \frac{\sqrt{5}\phi^k + \sqrt{5}\psi^k}{2\sqrt{5}}
    \notag\\
    &= \frac{\FIB(k)}{2} + \frac{\phi^k + \psi^k}{2}
    \tag{귀납 가정에 의해}\\
    &= \frac{\FIB(k)}{2} + \frac{\FIB(k)}{2} + \FIB(k-1)
    \tag{$\star$에 의해}\\
    &= \FIB(k) + \FIB(k-1)\notag
  \end{align}
  \QED
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.14}

그림 \ref{fig:count-change}\는 \texttt{(count-change 11)}가 계산되는 과정을 트리
형태로 나타낸 것이다.

\TODO

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{ch01-ex14}
  \caption{\texttt{(count-change 11)} 계산 과정을 나타내는 트리}
  \label{fig:count-change}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.15}

다음은 \texttt{(sine 12.15)}가 계산되는 도중 프로시저 \texttt{p}가 호출되는
모습을 나타낸 것이다 (몇몇 수는 소수점 이하가 정확하지 않을 수 있음).

\begin{scheme}
> (sine 12.15)
> (p (sine 4.05))
> (p (p (sine 1.3499999999)))
> (p (p (p (sine 0.4499999999))))
> (p (p (p (p (sine 0.15)))))
> (p (p (p (p (p (sine 0.049999999999))))))
> (p (p (p (p 0.1495))))
> (p (p (p 0.43513455))))
> (p (p 0.97584653))
> (p -0.7895631)
-0.39980345741334
\end{scheme}

\renewcommand{\theenumi}{\alph{enumi}}
\begin{enumerate}
\item \texttt{(sine 12.15)}를 계산할 때 프로시저 \texttt{p}는 5번 적용되었다.
\item 프로시저 \texttt{p}는 주어진 인자에 계속 3을 나눠가면서 0.1 이하가 될
  때까지 적용된다. 즉 $\Theta(log_3n)$의 계산횟수 증가율을 보인다. 그리고
  계산횟수가 증가함에 따라 동일한 비율로 프로시저 \texttt{p} 호출 횟수가
  증가하므로, 공간 증가율 역시 $\Theta(log_3n)$로 볼 수 있다.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.16}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.17}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.18}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.19}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 

\appendix
\chapter{Objective-Caml 구현}

이 장에서 기술된 코드는 앞에서 \SCHEME으로 작성된 코드를 \OCAML\footnote{\URL{http://caml.inria.fr}}로 다시 구현한
것이다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.3}
\ocaml{./src/ch01-ex03.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.7}
\ocaml{./src/ch01-ex07.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.8}
\ocaml{./src/ch01-ex08.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.11}
\ocaml{./src/ch01-ex11.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.12}
\ocaml{./src/ch01-ex12.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.16}
\ocaml{./src/ch01-ex16.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.17}
\ocaml{./src/ch01-ex17.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.18}
\ocaml[7]{./src/ch01-ex18.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.19}
\ocaml{./src/ch01-ex19.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.22}

\OCAML에서 \SCHEME의 \texttt{(runtime)}과 유사한 기능을 하는 함수는
\texttt{Unix} 라이브러리의 \texttt{Unix} 모듈에 있는 \texttt{gettimeofday}
함수이다. \texttt{Unix} 라이브러리는 표준 라이브러리가 아니므로 자동으로
로드되지 않는다. 따라서 사용자가 직접 \texttt{unix.cma} 혹은
\texttt{unix.cmxa}를 사용할 것임을 명시해야 한다\footnote{\OCAML~인터랙티브
  환경에서는 프롬프트에서 \texttt{\#load "unix.cma"} 명령을 수행하면
  \texttt{Unix} 모듈을 사용할 수 있다.}.

\ocaml{./src/ch01-ex22.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.23}
\ocaml{./src/ch01-ex23.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.24}

\OCAML의 \texttt{int} 타입은 큰 수를 다룰 수가 없다. 따라서 \texttt{expmod}
함수를 \texttt{int} 값에 대해 계산하도록 작성하면 \KOEN{정수넘침}{integer overflow}이
발생하여 잘못된 계산이 수행될 수 있다. 이러한 문제를 해결하기 위해 여기서는
일반적인 정수 계산 대신 \texttt{Num} 라이브러리의 \texttt{Big\_int} 모듈에서
제공하는 함수를 사용한다. \texttt{Num} 라이브러리 또한 \texttt{Unix}
라이브러리처럼 표준 라이브러리가 아니므로 사용자가 직접 \texttt{nums.cma} 혹은
\texttt{nums.cmxa}를 사용할 것임을 명시해야 한다.

\ocaml{./src/ch01-ex24.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.27}
\ocamlpart{./src/ch01-ex27.ml}{45}{55}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.28}
\ocaml{./src/ch01-ex28.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.29}
\ocaml{./src/ch01-ex29.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.30}
\ocaml{./src/ch01-ex30.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.31}
\ocaml{./src/ch01-ex31.ml}

\texttt{approx\_pi} 프로시저를 구현할 때, 주어진 식에서 분자와 분모를 따로
구한 후 나누는 식으로(즉, \texttt{product}를 두 번 사용한 결과를 나눔) 구현하지
않도록 한다. 왜냐하면 인자로 큰 값이 주어졌을때 곱해진 결과가 매우 큰 값이
되어버리기 때문이다. 비교적 큰 수를 잘 다루는 \SCHEME에서는 문제가 없으나,
\OCAML의 경우에는 값의 한계가 있기 때문에 제대로 동작하지 않을 수 있다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.32}
\ocaml{./src/ch01-ex32.ml}

\texttt{accumulate} 함수를 사용하여 \texttt{prodcut}와 \texttt{sum}을 구현할
때 \texttt{combiner}로 쓰일 연산자를 넘기려면 \SCHEME에서와 달리 연산자를
괄호로 묶어야 한다. 기본적으로 \OCAML의 연산자는 값처럼 다룰 수 없는
infix 연산자이다. 예를 들어 \texttt{f a + b}는 함수 \texttt{f}에
\texttt{a},\texttt{+},\texttt{b} 인자를 적용하는 것이 아니라, \texttt{(f a) +
  b} 처럼 해석된다. 하지만 이러한 연산자도 괄호로 묶이면 값처럼 다룰 수
있는(인자로 사용 가능) prefix 연산자가 된다. 다음 예를 참고하라.

\begin{lstlisting}
# 3 + 5;;
- : int = 8
# (+) 3 5;;
- : int = 8
# let apply f a b = f a b;;
val apply : ('a -> 'b -> 'c) -> 'a -> 'b -> 'c = <fun>
# apply + 3 5;;                    (*** same as (apply) + (3 5) ***)
Characters 0-5:
  apply + 3 5;;
  ^^^^^
Error: This expression has type ('a -> 'b -> 'c) -> 'a -> 'b -> 'c
       but an expression was expected of type int
# apply (+) 3 5;;
- : int = 8
\end{lstlisting}

덧붙여 `\texttt{*}'나 `\texttt{*.}' 연산자와 같이 `\texttt{*}'로 시작하는
연산자를 괄호로 묶을때는 여는 괄호와 `\texttt{*}'가 붙지 않게 사이에 공백을
넣어야 한다. 만일 `\texttt{(*}'와 같이 공백을 빠트리면 이는 주석의 시작을
의미하게 된다.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.33}
\ocaml{./src/ch01-ex33.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.36}
\ocaml{./src/ch01-ex36.ml}

다음은 작성한 프로그램으로 교재에서 제시한 식의 고정점을 구해본 것이다.

\begin{lstlisting}[language={[Objective]Caml}]
# fixed_point (fun x -> 1.0 +. (1.0 /. x)) 1.0;;
1: 1.
2: 2.
3: 1.5
4: 1.66666666667
5: 1.6
6: 1.625
7: 1.61538461538
8: 1.61904761905
9: 1.61764705882
10: 1.61818181818
11: 1.61797752809
12: 1.61805555556
13: 1.61802575107
14: 1.61803713528
15: 1.61803278689
- : float = 1.61803278688524577
# let average x y = (x +. y) /. 2.0;;
val average : float -> float -> float = <fun>
# fixed_point (fun x -> average x ((log 1000.0) /. (log x))) 10.0;;
1: 10.
2: 6.5
3: 5.09521509918
4: 4.66876068128
5: 4.57585730577
6: 4.55903011671
7: 4.55613168521
8: 4.55563720616
9: 4.55555298755
10: 4.5555386477
11: 4.55553620619
- : float = 4.55553620618503885
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.37}
\ocaml{./src/ch01-ex37.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.38}
\ocaml[10]{./src/ch01-ex38.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.39}
\ocaml[12]{./src/ch01-ex39.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.40}
\ocaml[20]{./src/ch01-ex40.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.41}
\ocaml{./src/ch01-ex41.ml}

%%%%%%%%%p%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.42}
\ocaml{./src/ch01-ex42.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.43}
\ocaml[3]{./src/ch01-ex43.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.44}
\ocaml[8]{./src/ch01-ex44.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.45}
\ocaml[29]{./src/ch01-ex45.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{1.46}
\ocaml[7]{./src/ch01-ex46.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.1}

다음 구현처럼 \OCAML에서 값의 쌍을 다룰 때는 일반적인 리스트 대신
\KOEN{튜플}{tuple}을 사용하는 것이 좋다.

\ocaml[7]{./src/ch02-ex01.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.2}

\SCHEME과 달리 \OCAML은 \KOEN{타입이 엄격한 언어}{strongly-typed
  language} 이다. 이는 좀 더 견고한 프로그램을 만들 수 있게 해주는데, 다음
구현이 그것의 한 예를 보여주고 있다. 여기서는 \texttt{point}, \texttt{segment}
타입을 정의한 후 해당하는 \KOEN{구성자}{constructor}와
\KOEN{선택자}{selector}가 의도한 타입의 값만을 받도록 하였다. 예를 들어
\texttt{x\_point}는 \texttt{point} 타입의 값만을 받는다. 이와 달리
앞에서 \SCHEME으로 작성한 \texttt{x-point} 프로시져는 가능한 인자를 한정짓지
않고 무조건 \texttt{car}를 적용하기 때문에, \texttt{(cons (cons 1 5) 3)}과
같은 의도치 않은 인자에 대해서도 결과를 내주게 된다.

\ocaml{./src/ch02-ex02.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.3}

\ocaml[34]{./src/ch02-ex03.ml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.4}

\ocaml{./src/ch02-ex04.ml}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
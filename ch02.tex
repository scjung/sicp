\chapter{\Large{Building Abstractions with Data}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.1}

문제에서 제시하는 정리 방법을 간단히 말하면 분모가 항상 양수가 되게 하라는
것이다. 즉 분모가 음수일 때 분자, 분모 각각의 부호를 바꾸어 주면 된다.

\scheme[6]{./src/ch02-ex01.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.2}

\scheme{./src/ch02-ex02.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.3}

다음 구현에서 나타난 \texttt{make-rect} 프로시저는 구성하고자 하는 직사각형의
왼쪽 상단과 오른쪽 하단의 점을 받고서
(모든 내각이 직각인 사실을 바탕으로) 모든 점을 구해낸 후 \KOEN{쌍}{pair}의 쌍으로
묶어낸다. 이러한 방식으로 구현된 전체 프로그램의 추상화 구조를 나타내면 그림
\ref{fig:absrect}과 같다. 그림에서 볼 수 있듯이, 다른 구조로 직사각형을
나타내고자 할 때에는 구성자와 꼭지점을 내주는 선택자만 변경하면 된다.
\begin{figure}[t]
  \centering
  \HR{2em}\fbox{\parbox{27em}{\centering%
      \texttt{width-rect height-rect perimeter-rect area-rect}%
    }}\HR{2em}\vspace{1em}\\
  네 변으로 구성되는 직사각형 \vspace{1em}\\
  \HR{4em}\fbox{\parbox{23em}{\centering%
      \texttt{top-segment-rect left-segment-rect ...}%
    }}\HR{4em}\vspace{1em}\\
  네 꼭지점으로 구성되는 직사각형 \vspace{1em}\\
  \HR{3em}\fbox{\parbox{25em}{\centering%
      \texttt{make-rect top-left-rect top-right-rect ...}}}\HR{3em}\vspace{1em}\\
  쌍의 쌍으로 구성되는 직사각형 \vspace{1em}\\
  \HR{11em}\fbox{\parbox{9em}{\centering\texttt{cons car cdr}}}\HR{11em}\vspace{1em}\\
  어떻게든 구현된 쌍\vspace{1em}\\
  \caption{직사각형 프로그램의 자료추상화 배리어}
  \label{fig:absrect}
\end{figure}

\scheme[29]{./src/ch02-ex03.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.4}

다음은 `\texttt{(car (cons x y))}'가 계산되는 과정을 나타낸 것이다.

\begin{lstlisting}[language=Scheme]
> (car (cons x y))
> (car (lambda (m) (m x y)))
> (lambda (m) (m x y)) (lambda (p q) p)
> (lambda (p q) p) x y
x
\end{lstlisting}

\texttt{cdr} 프로시저는 다음과 같이 구현할 수 있다.
\scheme[7]{./src/ch02-ex04.ss}

다음은 `\texttt{(cdr (cons x y))}'가 계산되는 과정을 나타낸 것이다.

\begin{lstlisting}[language=Scheme]
> (cdr (cons x y))
> (cdr (lambda (m) (m x y)))
> (lambda (m) (m x y)) (lambda (p q) q)
> (lambda (p q) q) x y
y
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.5}

주어진 식에 따르면 2는 $2^a$
항만 나누어 떨어지게 할 수 있고, 3은 $3^b$만을 나누어 떨어지게 할 수 있다. 즉
제안된 방식으로 표현된 양수쌍을 나머지가 없을 동안 계속
2로 나누어 나가면 $3^b$ 항을 얻어낼 수 있으며, 반대로 3으로 나누어 나가면
$2^a$ 항을 얻어낼 수 있다. 다음은 이러한 성질을 이용하여
\texttt{cons}, \texttt{car}, \texttt{cdr} 프로시저를 구현한 것이다.

\scheme{./src/ch02-ex05.ss}

\SCHEME에서 기본으로 제공하는 \texttt{log} 프로시저는 자연로그임에 유의해야
한다. 앞의 프로그램에서는 다음 성질을 이용하여 $\log_2,\log_3$을 계산하였다.

\begin{equation}\notag
  \log_a b = \frac{\log_c b}{\log_c a}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.6}

다음은 주어진 프로시저를 적용하여 \texttt{one}, \texttt{two}의 정의를 얻어낸
것이다.

\begin{lstlisting}[language=Scheme]
;; one
> (add-1 zero)
> (add-1 (lambda (f) (lambda (x) x)))
> (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
> (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
(lambda (f) (lambda (x) (f x)))

;; two
> (add-1 one)
> (add-1 (lambda (f) (lambda (x) (f x))))
> (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
> (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (f (f x))))
\end{lstlisting}

덧셈 연산에 해당하는 \texttt{+} 프로시저는 다음과 같이 주어진
\texttt{f}, \texttt{x}를 앞의 수에 적용한 후, 그 결과를 연속적으로 뒤의 수에
적용하는 식으로 구현할 수 있다.

\scheme[10]{./src/ch02-ex06.ss}

다음은 `\texttt{(+ one one)}'의 결과가 `\texttt{two}'가 되는지 확인해 본
것이다. 치환과정을 간단히 나타내기 위해 계산순서를 약간 달리 하였다.

\begin{lstlisting}[language=Scheme]
> (+ one one)
> (lambda (f) (lambda (x) ((one f) ((one f) x))))
> (lambda (f) (lambda (x) ((lambda (x) (f x)) ((lambda (x) (f x)) x))))
> (lambda (f) (lambda (x) ((lambda (x) (f x)) (f x))))
(lambda (f) (lambda (x) (f (f x))))
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.7}

\scheme[20]{./src/ch02-ex07.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.8}

다음 성질을 이용하면 두 구간의 차를 쉽게 구할 수 있다.

\begin{equation}\notag
  x-y=x+(-y)
\end{equation}

두 구간의 차를 구하려면 일단 두번째 구간의 상한과 하한에 -를 취하고, 부호가
바뀌면 크기 관계가 뒤바뀌는 것을 고려하여 상한과 하한을 바꾼다. 이렇게 바뀐
구간과 첫번째 구간을 더하면 결과를 얻을 수 있다. 다음은 이러한 방식으로 구현한
\texttt{sub-interval} 프로시저이다.

\scheme[24]{./src/ch02-ex08.ss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\exercise{2.9}

상한 $u$와 하한 $l$로 이루어지는 구간 $i$를 다음과 같이 표현하자.
\begin{equation}\notag
  i = [l, u]
\end{equation}

두 구간 $i_1=[l_1,u_1]$, $i_2=[l_2,u_2]$를 더한 구간의 너비 $w$는 다음과 같다.
\begin{align}
  w(i_1 + i_2) & = w([l_1+l_2,u_1+u_2])
  \notag\\
  & = \frac{(u_1+u_2)-(l_1+l_2)}{2}
  \notag\\
  & = \frac{u_1-l_1}{2} + \frac{u_2-l_2}{2}
  \notag\\
  & = w(i_1) + w(i_2)
  \notag
\end{align}

즉, 더한 결과에 구간을 적용하는 것과 구간을 적용한 후 더하는 것 모두 같은
결과를 내준다. 두 구간을 빼는 경우에도 마찬가지로 이러한 성질이
적용된다. 하지만 곱셈과 나눗셈의 경우에는 성질을 적용할 수 없다. 다음은 성질을
만족하지 않는 한 예이다.
\begin{align}
  w([-2,2]\times[4,8]) & = w([-8,16]) = 12 \notag \\
  w([-2,2]) \times w([4,8]) & = 2 \times 2 = 4 \notag \\
  w([-2,2]/[4,8]) & = w([-0.5,0.5]) = 0.5 \notag \\
  w([-2,2]) / w([4,8]) & = 2 / 2 = 1 \notag
\end{align}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
